= sycl_ext_oneapi_complex

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2022-2022 Codeplay Ltd.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 5 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*

[NOTE]
====
This extension is not currently implemented in {dpcpp}.
====


== Overview

{dpcpp} has support for `sycl::ext::oneapi::complex` this allows for the
addition of new complex math features. This proposes the specialization of
`marray` to add support for complex numbers to be stored in arrays. The
proposal includes overloading the existing math functions to support complex
marrays and adding new free functions to simplify accessing, setting marray
values, and construct complex marrays.

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_ONEAPI_MARRAY_COMPLEX` to one of the values defined in the table
below.  Applications can test for the existence of this macro to determine if
the implementation supports this feature, or applications can test the macro's
value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|Initial version of this extension.
|===

=== Marray Complex Class Specialization

The `marray` class is specialized for the `sycl::ext::oneapi::complex`
class. The user interface of the `marray<sycl::ext::oneapi::complex, {N}>`
class is similar to the SYCL-2020 generic `marray` interface. Some logical,
bitwise, and arithmetic operators are deleted for the complex class as there is
no equivalent.

The marray complex specialization is trivially copyable, and the type trait
`is_device_copyable` should resolve to `std::true_type`.

```C++
namespace sycl {
namespace ext {
namespace oneapi {

    // Specialization of exiting `marray` class for `sycl::ext::oneapi::complex`
    template <typename T, std::size_t NumElements>
    class marray <sycl::ext::oneapi::complex<T>, NumElements> {
        private:
            using DataT = sycl::ext::oneapi::complex<T>;
        public:
            using value_type = DataT;
            using reference = DataT&;
            using const_reference = const DataT&;
            using iterator = DataT*;
            using const_iterator = const DataT*;

            marray();

            explicit constexpr marray(const DataT &arg);

            template <typename... ArgTN>
            constexpr marray(const ArgTN&... args);

            constexpr marray(const marray<DataT, NumElements> &rhs);
            constexpr marray(marray<DataT, NumElements> &&rhs);

            // Available only when: NumElements == 1
            operator DataT() const;

            static constexpr std::size_t size() noexcept;

            // subscript operator
            reference operator[](std::size_t index);
            const_reference operator[](std::size_t index) const;

            marray &operator=(const marray<DataT, NumElements> &rhs);
            marray &operator=(const DataT &rhs);

            // iterator functions
            iterator begin();
            const_iterator begin() const;

            iterator end();
            const_iterator end() const;

            // OP is: +, -, *, /
            friend marray operatorOP(const marray &lhs, const marray &rhs) { /* ... */ }
            friend marray operatorOP(const marray &lhs, const DataT &rhs) { /* ... */ }

            // OP is: %
            friend marray operatorOP(const marray &lhs, const DataT &rhs) = delete;
         
            // OP is: +=, -=, *=, /=
            friend marray &operatorOP(marray &lhs, const marray &rhs) { /* ... */ }
            friend marray &operatorOP(marray &lhs, const DataT &rhs) { /* ... */ }

            // OP is: %=
            friend marray &operatorOP(marray &lhs, const marray &rhs) = delete;
            friend marray &operatorOP(marray &lhs, const DataT &rhs) = delete;
         
            // OP is prefix ++, --
            friend marray &operatorOP(marray &rhs) = delete;
         
            // OP is postfix ++, --
            friend marray operatorOP(marray& lhs, int) = delete;
         
            // OP is unary +, -
            friend marray operatorOP(marray &rhs) = delete;
         
            // OP is: &, |, ^
            friend marray operatorOP(const marray &lhs, const marray &rhs) = delete;
            friend marray operatorOP(const marray &lhs, const DataT &rhs) = delete;
         
            // OP is: &=, |=, ^=
            friend marray &operatorOP(marray &lhs, const marray &rhs) = delete;
            friend marray &operatorOP(marray &lhs, const DataT &rhs) = delete;
         
            // OP is: &&, ||
            friend marray<bool, NumElements> operatorOP(const marray &lhs, const marray &rhs) = delete;
            friend marray<bool, NumElements> operatorOP(const marray& lhs, const DataT &rhs) = delete;
         
            // OP is: <<, >>
            friend marray operatorOP(const marray &lhs, const marray &rhs) = delete;
            friend marray operatorOP(const marray &lhs, const DataT &rhs) = delete;
         
            // OP is: <<=, >>=
            friend marray &operatorOP(marray &lhs, const marray &rhs) = delete;
            friend marray &operatorOP(marray &lhs, const DataT &rhs) = delete;
         
            // OP is: ==, !=
            friend marray<bool, NumElements> operatorOP(const marray &lhs, const marray &rhs) {
            /* ... */ }
            friend marray<bool, NumElements> operatorOP(const marray &lhs, const DataT &rhs) {
            /* ... */ }

            // OP is: <, >, <=, >=
            friend marray<bool, NumElements> operatorOP(const marray &lhs, const marray &rhs) = delete;
            friend marray<bool, NumElements> operatorOP(const marray &lhs, const DataT &rhs) = delete;
         
            friend marray operator~(const marray &v) = delete;
         
            // OP is: +, -, *, /
            friend marray operatorOP(const DataT &lhs, const marray &rhs) { /* ... */ }

            // OP is: %
            friend marray operatorOP(const DataT &lhs, const marray &rhs) = delete;
         
            // OP is: &, |, ^
            friend marray operatorOP(const DataT &lhs, const marray &rhs) = delete;
         
            // OP is: &&, ||
            friend marray<bool, NumElements> operatorOP(const DataT &lhs, const marray &rhs) {
            /* ... */ }
         
            // OP is: <<, >>
            friend marray operatorOP(const DataT &lhs, const marray &rhs) = delete;
         
            // OP is: ==, !=
            friend marray<bool, NumElements> operatorOP(const DataT &lhs, const marray &rhs) {
            /* ... */ }

            // OP is: <, >, <=, >=
            friend marray<bool, NumElements> operatorOP(const DataT &lhs, const marray &rhs)  = delete;
         
            friend marray<bool, NumElements> operator!(const marray &v) = delete;
    }

} // namespace oneapi
} // namespace ext
} // namespace sycl
```

The list of deleted operators are: %, %=, ++, --, +, -, &, |, ^, &=, |=, ^=,
&&, ||, <<, >>, <<=, >>=, <, >, <=, >=, ~, !

The `make_complex_marray` free function is added to construct complex marrays from real and
imaginary components. Additionally, the free functions `get_real` and
`get_imag` are added to access the real and imaginary components of the
`marray` class without modifying the existing `marray` interface. The usage
of free functions does cause a deviation from the `std::complex` interface.
However, it does reduce this extensions impact on the `marray` interface.

```C++
namespace sycl {
namespace ext {
namespace oneapi {

  // Make_complex_marray

  template <class T, std::size_t NumElements>
  marray<sycl::ext::oneapi::complex<T> make_complex_marray(marray<T, NumElements> &real, marray<T, NumElements> &imag);

  template <class T, std::size_t NumElements>
  marray<sycl::ext::oneapi::complex<T> make_complex_marray(marray<T, NumElements> &real, T imag);

  template <class T, std::size_t NumElements>
  marray<sycl::ext::oneapi::complex<T> make_complex_marray(T real, marray<T, NumElements> &imag);

  // Get

  // return marray of component
  template <class T, std::size_t NumElements>
  marray<T> get_real(marray<sycl::ext::oneapi::complex<T>, NumElements> &input);

  template <class T, std::size_t NumElements>
  marray<T> get_imag(marray<sycl::ext::oneapi::complex<T>, NumElements> &input);

  // return element of component
  template <class T, std::size_t NumElements>
  T get_real(marray<sycl::ext::oneapi::complex<T>, NumElements> &input, std::size_t index);

  template <class T, std::size_t NumElements>
  T get_imag(marray<sycl::ext::oneapi::complex<T>, NumElements> &input, std::size_t index);

  // Set

  template <class T, std::size_t NumElements>
  void set_real(marray<sycl::ext::oneapi::complex<T>, NumElements> &input, marray<sycl::ext::oneapi::complex<T>, NumElements> &values);

  template <class T, std::size_t NumElements>
  void set_imag(marray<sycl::ext::oneapi::complex<T>, NumElements> &input, marray<sycl::ext::oneapi::complex<T>, NumElements> &values);

  template <class T, std::size_t NumElements>
  void set_real(marray<sycl::ext::oneapi::complex<T>, NumElements> &input, std::size_t index, T value);

  template <class T, std::size_t NumElements>
  void set_imag(marray<sycl::ext::oneapi::complex<T>, NumElements> &input, std::size_t index, T value);

} // namespace oneapi
} // namespace ext
} // namespace sycl
```

The class `sycl::oneapi::marray<complex<T>, N>`, has specializations
of `T`; `float`, `double`, and `sycl::half` defined.

```C++
namespace sycl {
namespace ext {
namespace oneapi {

  template <std::size_t NumElements>
  class marray<double, NumElements>;

  template <std::size_t NumElements>
  class marray<float, NumElements>;

  template <std::size_t NumElements>
  class marray<sycl::half, NumElements>;

} // namespace oneapi
} // namespace ext
} // namespace sycl
```

The generic type `mgencomplex` is defined as types
`marray<complex<double>, {N}>`, `complex<complex<float>, {N}>`,
`complex<complex<sycl::half>, {N}>`.

The table below shows the free functions operating on the `marray` complex
specialized class. No table is provided for the `marray` class as only
functions are removed and the underlying function defintion stays the same.

[%header,cols="5,5"]
|===
|Function
|Description

|`mgencomplex make_complex_marray(mgenfloat& x, mgenfloat& y);`
|Constructs a marray of complex numbers with real values in marray x, and the imaginary values in marray y.
|`mgencomplex make_complex_marray(mgenfloat& x, genfloat& y);`
|Constructs a marray of complex numbers with real values in marray x, and the imaginary value y.
|`mgencomplex make_complex_marray(genfloat& x, mgenfloat& y);`
|Constructs a marray of complex numbers with real value x, and the imaginary values in marray y.
|`mgenfloat get_real(mgencomplex& x);`
|Returns an marray of the real components for marray of complex numbers.
|`mgenfloat get_imag(mgencomplex& x);`
|Returns an marray of the imaginary components for marray of complex numbers.
|`mgenfloat get_real(mgencomplex& x, std::size_t idx);`
|Returns the real component of the complex number for element idx in marray x.
|`mgenfloat get_imag(mgencomplex& x, std::size_t idx);`
|Returns the imaginary component of the complex number for element idx in marray x.
|`void set_real(mgencomplex& x, mgenfloat& y);`
|Set each element of the real components in x to the corresponding element in y.
|`void set_imag(mgencomplex& x, mgenfloat& y);`
|Set each element of the imaginary components in x to the corresponding element in y.
|`void set_real(mgencomplex& x, std::size_t idx, genfloat& y);`
|Set each element of the real components in x to the decimal number y.
|`void set_imag(mgencomplex& x, std::size_t idx, genfloat& y);`
|Set each element of the imaginary components in x to the decimal number y.


=== Mathematical operations

This proposal extends `sycl::ext::oneapi` namespace math functions to accept
`mgencomplex` for the SYCL math functions, `abs`, `acos`, `asin`, `atan`,
`acosh`, `asinh`, `atanh`, `arg`, `conj`, `cos`, `cosh`, `exp`, `log`, `log10`,
`norm`, `polar`, `pow`, `proj`, `sin`, `sinh`, `sqrt`, `tan`, and `tanh`.
For math functions with two parameters marray-scalar and scalar-marray overloads
are added.

The functions execute as-if the math operation is performed elementwise across the
marray. The math function between each element should follow the C++ 
standard for handling NaN's and Inf values. 

The proposal additionally adds overloads between marrays and scalar inputs.
Overloads with marray's and scalar parameters should execute the operation 
across the marray while keeping the scalar value constant.

```C++
namespace sycl {
namespace ext {
namespace oneapi {

    mgenfloat abs(const mgencomplex& x);

    mgencomplex acos(const mgencomplex& x);

    mgencomplex asin(const mgencomplex& x);

    mgencomplex atan(const mgencomplex& x);

    mgencomplex acosh(const mgencomplex& x);

    mgencomplex asinh(const mgencomplex& x);

    mgencomplex atanh(const mgencomplex& x);

    mgenfloat arg(const mgencomplex& x);

    mgencomplex conj(const mgencomplex& x);

    mgencomplex cos(const mgencomplex& x);

    mgencomplex cosh(const mgencomplex& x);

    mgencomplex exp(const mgencomplex& x);

    mgencomplex log(const mgencomplex& x);

    mgencomplex log10(const mgencomplex& x);

    mgenfloat norm(const mgencomplex& x);

    mgencomplex polar(const mgenfloat& rho, const mgenfloat& theta = 0);
    mgencomplex polar(const mgenfloat& rho, const genfloat& theta = 0);
    mgencomplex polar(const genfloat& rho, const mgenfloat& theta = 0);

    mgencomplex pow(const mgencomplex& x, const mgenfloat& y);
    mgencomplex pow(const mgencomplex& x, const genfloat& y);
    mgencomplex pow(const gencomplex& x, const mgenfloat& y);

    mgencomplex pow(const mgencomplex& x, const mgencomplex& y);
    mgencomplex pow(const mgencomplex& x, const gencomplex& y);
    mgencomplex pow(const gencomplex& x, const mgencomplex& y);

    mgencomplex pow(const mgenfloat& x, const mgencomplex& y);
    mgencomplex pow(const mgenfloat& x, const gencomplex& y);
    mgencomplex pow(const genfloat& x, const mgencomplex& y);

    mgencomplex proj(const mgencomplex& x);

    mgencomplex sin(const mgencomplex& x);

    mgencomplex sinh(const mgencomplex& x);

    mgencomplex sqrt(const mgencomplex& x);

    mgencomplex tan(const mgencomplex& x);

    mgencomplex tanh(const mgencomplex& x);

} // namespace oneapi
} // namespace ext
} // namespace sycl
```

The table below shows each function along with a description of its
mathematical operation.

[%header,cols="5,5"]
|===
|Function
|Description

|`mgenfloat abs(const mgencomplex& x)`
|Compute the magnitude for each complex number in marray x.
|`mgencomplex acos(const mgencomplex& x)`
|Compute the inverse cosine for each complex number in marray x.
|`mgencomplex asin(const mgencomplex& x)`
|Compute the inverse sine for each complex number in marray x.
|`mgencomplex atan(const mgencomplex& x)`
|Compute the inverse tangent for each complex number in marray x.
|`mgencomplex acosh(const mgencomplex& x)`
|Compute the inverse hyperbolic cosine for each complex number in marray x.
|`mgencomplex asinh(const mgencomplex& x)`
|Compute the inverse hyperbolic sine for each complex number in marray x.
|`mgencomplex atanh(const mgencomplex& x)`
|Compute the inverse hyperbolic tangent for each complex number in marray x.
|`mgenfloat arg(const mgencomplex& x);`
|Compute phase angle in radians for each complex number in marray x.
|`mgencomplex conj(const mgencomplex& x)`
|Compute the conjugate for each complex number in marray x.
|`mgencomplex cos(const mgencomplex& x)`
|Compute the cosine for each complex number in marray x.
|`mgencomplex cosh(const mgencomplex& x)`
|Compute the hyperbolic cosine for each complex number in marray x.
|`mgencomplex exp(const mgencomplex& x)`
|Compute the base-e exponent for each complex number in marray x.
|`mgencomplex log(const mgencomplex& x)`
|Compute the natural log for each complex number in marray x.
|`mgencomplex log10(const mgencomplex& x)`
|Compute the base-10 log for each complex number in marray x.
|`mgenfloat norm(const mgencomplex& x)`
|Compute the squared magnitude for each complex number in marray x.
|`mgencomplex polar(const mgenfloat& rho, const mgenfloat& theta = 0)`
|Construct an marray, elementwise, of complex numbers from each polar coordinate in marray rho and marray theta.
|`mgencomplex polar(const mgenfloat& rho, const genfloat& theta = 0)`
|Construct an marray, elementwise, of complex numbers from each polar coordinate in marray rho and scalar theta.
|`mgencomplex polar(const genfloat& rho, const mgenfloat& theta = 0)`
|Construct an marray, elementwise, of complex numbers from each polar coordinate in scalar rho and marray theta.
|`mgencomplex pow(const mgencomplex& x, const mgenfloat& y)`
|Raise each complex element in x to the power of the corresponding decimal element in y.
|`mgencomplex pow(const mgencomplex& x, const genfloat& y)`
|Raise each complex element in x to the power of the decimal numer y.
|`mgencomplex pow(const gencomplex& x, const mgenfloat& y)`
|Raise complex number x to the power of each decimal element in y.
|`mgencomplex pow(const mgencomplex& x, const mgencomplex& y)`
|Raise each complex element in x to the power of the corresponding complex element in y.
|`mgencomplex pow(const mgencomplex& x, const gencomplex& y)`
|Raise each complex element in x to the power of the complex number y.
|`mgencomplex pow(const gencomplex& x, const mgencomplex& y)`
|Raise complex number x to the power of each complex element in y.
|`mgencomplex pow(const mgenfloat& x, const mgencomplex& y)`
|Raise each decimal element in x to the power of the corresponding complex element in y.
|`mgencomplex pow(const mgenfloat& x, const gencomplex& y)`
|Raise each decimal element in x to the power of the complex number y.
|`mgencomplex pow(const genfloat& x, const mgencomplex& y)`
|Raise decimal number x to the power of each complex element in y.
|`mgencomplex proj(const mgencomplex& x)`
|Compute the projection for each complex number in marray x.
|`mgencomplex sin(const mgencomplex& x)`
|Compute the sine for each complex number in marray x.
|`mgencomplex sinh(const mgencomplex& x)`
|Compute the hyperbolic sine for each complex number in marray x.
|`mgencomplex sqrt(const mgencomplex& x)`
|Compute the square root for each complex number in marray x.
|`mgencomplex tan(const mgencomplex& x)`
|Compute the tangent for each complex number in marray x.
|`mgencomplex tanh(const mgencomplex& x)`
|Compute the hyperbolic tangent for each complex number in marray x.
|===
